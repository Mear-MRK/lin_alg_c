#pragma once

#include <stdbool.h>
#include <stddef.h>

#include "payload.h"
#include "lin_alg_config.h"


/**
 * vec - Vector type.
 *
 * This struct represents a vector with elements of type FLT_TYP.
 * It contains:
 * - pyl: Pointer to the payload containing the actual vector data.
 * - d: Dimension of the vector.
 * - offset: Index offset for this vector into pyl's data array.
 * - step: Step size between successive elements.
 */
typedef struct vec
{
    payload *pyl;
    IND_TYP d;
    IND_TYP offset;
    IND_TYP step;
} vec;

/**
 * The empty (NULL) vector.
 * It's a good practice to initialize any
 * declared vec with this value.
 */
#define vec_NULL ((const vec){.pyl = NULL, .d = 0, .offset = 0, .step = 0})

/**
 * Checks to find if vec v is vec_NULL
 */
bool vec_is_null(const vec *v);

/**
 * Checks if the given vector v is valid.
 *
 * Valid means v is not NULL, v->d > 0, and v->pyl is not NULL.
 */
bool vec_is_valid(const vec *v);

/*
 * Allocates `d` FLT_TYP for v->pyl->arr.
 * `d` must be non-zero;
 * vec_destruct must be called on v at the end of its lifetime.
 * Content of v->pyl->arr is garbage.
 */
vec *vec_construct(vec *v, IND_TYP d);

/**
 * Constructs vector v by pre-allocating its payload pyl.
 *
 * This sets v's pyl, offset, dimension d and step. The values in pyl->arr are not initialized.
 * Caller must ensure pyl->arr has sufficient allocated space for the vector.
 *
 * @param v Vector to construct by pre-allocation.
 * @param pyl Payload with pre-allocated array to use.
 * @param offset Index offset into pyl's array for this vector.
 * @param d Dimension of the vector.
 * @param step Step size between successive elements.
 * @return v
 */
vec *vec_construct_prealloc(vec *v, payload *pyl, IND_TYP offset, IND_TYP d, IND_TYP step);

/*
 * Frees v->pyl->arr and sets *v = vec_NULL.
 * Should be called on v's that are constructed by vec_construct*.
 */
void vec_destruct(vec *v);

/*
 * Allocates a vec in heap, constructs it and returns it.
 * One should call vec_del on it to destruct and free the resources.
 */
vec *vec_new(IND_TYP d);

/*
 * Destructs v and frees v
 * which must be allocated by vec_new.
 */
void vec_del(vec *v);

/* NOT implemented yet.
vec* vec_construct_nil(vec* v, IND_TYP d);
vec* vec_construct_unit(vec* v, IND_TYP d, IND_TYP i);
vec* vec_construct_copy(vec* v, const vec* oth);
*/

/**
 * Reforms the vector v by changing its dimension, offset and step size.
 * The values in v->pyl->arr are unchanged.
 *
 * @param v Vector to reform
 * @param offset New offset into pyl->arr
 * @param d New dimension
 * @param step New step size
 * @return Reformed v
 */
vec *vec_reform(vec *v, IND_TYP offset, IND_TYP d, IND_TYP step);

/**
 * Creates a view of the vector src from indices start to stop (exclusive)
 * with given step size. The view shares src's payload.
 *
 * @param view The view vector to create
 * @param src The source vector
 * @param start The start index of the view
 * @param stop The stop index of the view (exclusive)
 * @param step The step size between indices
 * @return The created view vector
 */
vec *vec_view(vec *view, const vec *src, IND_TYP start, IND_TYP stop, IND_TYP step);

vec *vec_new_view(const vec *src, IND_TYP start, IND_TYP stop, IND_TYP step);

// v_dst = v_src : copies src->pyl->arr to dst->pyl->arr; dimensions must be the same.
vec *vec_assign(vec *v_dst, const vec *v_src);

// Copies src_arr to v->pyl->arr
vec *vec_copy_arr(vec *v, const FLT_TYP src_arr[]);

// Sets all elements of v->pyl->arr to 0
vec *vec_fill_zero(vec *v);

// Fills v->pyl->arr with random numbers generated by rnd_gen
vec *vec_fill_rnd(vec *v, FLT_TYP (*rnd_gen)(void));

vec *vec_fill_gen(vec *v, FLT_TYP (*gen)(const void*), const void *param);

// Fills v->pyl->arr with value
vec *vec_fill(vec *v, FLT_TYP value);

/* Same as vec_fill with alternative geometric memcpy algorithm.
vec *vec_fill_altimp(vec *v, FLT_TYP value);
*/

// Gives string representation of vec v; be sure str_buff is big enough.
char *vec_to_str(const vec *v, char *str_buff);

// Checks closeness of two vectors by comparing norm(v_1-v_2) and (norm(v_1)+norm(v_2))/2 * eps.
bool vec_is_close(const vec *v_1, const vec *v_2, FLT_TYP eps);

// result = v_left + v_right
vec *vec_add(vec *result, const vec *v_left, const vec *v_right);
// result = v_left - v_right
vec *vec_sub(vec *result, const vec *v_left, const vec *v_right);
// result = v_left * v_right (element-wise *)
vec *vec_mul(vec *result, const vec *v_left, const vec *v_right);
// result = v_left / v_right (element-wise /)
vec *vec_div(vec *result, const vec *v_left, const vec *v_right);
// result = alpha * v
vec *vec_sclmul(vec *result, const vec *v, FLT_TYP alpha);
// v_dst += v_right
vec *vec_addto(vec *v_dst, const vec *v_right);
// v_dst -= v_right
vec *vec_subfrom(vec *v_dst, const vec *v_right);
// v_dst *= v_right (element-wise *)
vec *vec_mulby(vec *v_dst, const vec *v_right);
// v += f
vec *vec_f_addto(vec *v, FLT_TYP f);
// result = f - v_right
vec *vec_f_sub(vec *result, FLT_TYP f, const vec *v_right);
// v *= scale
vec *vec_scale(vec *v, FLT_TYP scale);
// v_dst += alpha * v_right
vec *vec_update(vec *v_dst, FLT_TYP alpha, const vec *v_right);
// v_left @ v_right : @ = dot product
FLT_TYP vec_dot(const vec *v_left, const vec *v_right);
// Euclidean norm of v : sqrt(sum_i v->pyl->arr[i]^2)
FLT_TYP vec_norm_2(const vec *v);
// Sum of absolute values of v->pyl->arr
FLT_TYP vec_norm_1(const vec *v);
// Sum of elements of v
FLT_TYP vec_sum(const vec *v);
// Sign of elements of v
vec *vec_sign(vec *result, const vec *v);
// Theta: step function
vec *vec_theta(vec *result, const vec *v);

/* NOT implemented yet.
FLT_TYP vec_mean(const vec* v);
FLT_TYP vec_std(const vec* v);
*/

/* Applies map on each element of v->pyl->arr.
 * Don't use this in the cases where the function already
 * defined in the library. */
vec *vec_apply(vec *v, FLT_TYP (*map)(FLT_TYP));

// result = exp(v)
vec *vec_exp(vec *result, const vec *v);
// reslut = ln(v)
// vec *vec_ln(vec *result, const vec *v);
// result = log2(v)
vec *vec_log2(vec *result, const vec *v);
// result = 1 / v (element-wise inversion)
vec *vec_inv(vec *result, const vec *v);
// result = sqrt(v)
vec *vec_sqrt(vec *result, const vec *v);
// result = v^2
vec *vec_square(vec *result, const vec *v);
// result = tanh(v)
vec *vec_tanh(vec *result, const vec *v);
// result = sigmoid(v)
vec *vec_sigmoid(vec *result, const vec *v);
// result = ReLu(v)
vec *vec_relu(vec *result, const vec *v);
// result = softmax(v)
vec* vec_softmax(vec* result, const vec* v);
// return max element of v (first occurence)
FLT_TYP vec_max(const vec* v);
// return index of max element of v (first occurence)
IND_TYP vec_argmax(const vec* v);
// Gives a pointer to v->pyl->arr[i]; i can be negative
FLT_TYP *vec_at(const vec *v, IND_TYP i);
// Gives the serial size of vector v
size_t vec_serial_size(const vec *v);
// Returns the pointer to the first byte just after the last written byte to byte_arr
uint8_t *vec_serialize(const vec *v, uint8_t *byte_arr);
// Returns the pointer to the first byte just after the last read byte from byte_arr
const uint8_t *vec_deserialize(vec *v, const uint8_t *byte_arr);
